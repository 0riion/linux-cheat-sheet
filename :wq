# Bash


## Shell Types

### SH (Bourne Shell)

The original Unix shell, written by Steve Bourne. It is the default shell on most Unix systems.

### CSH (C Shell)

A shell written by Bill Joy. It is the default shell on most BSD systems, with a syntax similar to the C programming language.

### KSH (Korn Shell)

A shell written by David Korn. Combines the features of the KSH, XSH, SH and TSH shells.

### BASH (Bourne Again Shell)

A shell written by Brian Fox. It is the default shell on most Linux systems, and is a superset of the SH shell.

### ZSH (Z Shell)

A shell written by Paul Falstad. It is a superset of the KSH shell.


## What is Bash?

Bash is a command language interpreter that executes commands read from the standard input or from a file. Bash is a superset of the SH shell, and incorporates useful features from the KSH and CSH shells (see the comparison of shells).

## Create and Run a Bash Script

```bash
#!/bin/bash

pwd
ls
```

- add execute permission to the script

```bash
chmod +x script.sh
bash ./script.sh
./script.sh
```

## Variables

A variable could be a string, a number, a list of strings, a list of numbers, a list of lists, etc.

- **naming convention**: variable names can contain only letters, numbers, and the underscore character. They must begin with a letter,variable names are case sensitive.

```bash
#!/bin/bash
FIRST_NAME="John"
last_name="Doe"
age=25
```

### Scalar Variables

The simplest type of variable is a scalar variable, which contains a single value. A scalar variable can contain a string, a number, or a list of strings or numbers.

### Read-only Variables

```bash
#!/bin/bash
FIRST_NAME="John"
readonly FIRST_NAME
FIRST_NAME="Doe" # error
```

### Unsetting Variables

Unsetting a variable removes its value and makes it unavailable for use.

```bash
#!/bin/bash
FIRST_NAME="John"
unset FIRST_NAME
echo $FIRST_NAME # nothing
```

## Variable Types

### Local Variables

Local variables are variables that are available only within the current instance of the shell. Local variables are not passed to programs or scripts that are executed by the shell.

```bash
#!/bin/bash
function bash {
    local FIRST_NAME="John"
    echo $FIRST_NAME
}
bash
echo $FIRST_NAME # nothing
```

### Environment Variables

Environment variables are available to any child process of the shell. Environment variables are inherited by subshells, and can be passed to programs or scripts that are executed by the shell.

```bash
#!/bin/bash
FIRST_NAME="John"
export FIRST_NAME
bash
echo $FIRST_NAME # John
```

### Shell Variables

Shell variables are special variables that are set by the shell and are required for it to function properly.

```bash
#!/bin/bash
echo $BASH # /bin/bash
echo $BASH_VERSION # 4.4.12(1)-release
echo $HOME # /home/username
echo $PWD # /home/username
```

All shell variables:

| Variable | Description |
| --- | --- |
| $BASH | The full path of the bash executable |
| $BASH_VERSION | The version of bash |
| $HOME | The home directory of the current user |
| $PWD | The present working directory |
| $RANDOM | Returns a different random number each time is it referred to |
| $SECONDS | The number of seconds since the shell was started |
| $UID | The user ID of the current user |
| $USER | The username of the current user |
| $HOSTNAME | The hostname of the machine the shell is running on |
| $OSTYPE | The type of operating system the shell is running on |
| $MACHTYPE | The type of machine the shell is running on |
| $IFS | The Internal Field Separator |
| $LINENO | Returns the current line number in the Bash script |
| $PS1 | The primary prompt string |
| $PS2 | The secondary prompt string |
| $PS3 | The prompt string for select commands |
| $PS4 | The prompt string for debugging traces |
| $PATH | The search path for commands |
| $EDITOR | The default text editor for the shell |
| $MAIL | The location of the mailboxes |
| $MAILCHECK | The number of seconds between mail checks |
| $MAILPATH | The default location for new mail |
| $PAGER | The default program for paging output |
| $HISTSIZE | The number of commands to remember in the history list |
| $HISTFILESIZE | The number of commands to remember in the history file |
| $TERM | The type of terminal being used |
| $SHELL | The shell program being used |
| $OLDPWD | The previous working directory |
| $COLUMNS | The number of columns in the terminal |
| $LINES | The number of lines in the terminal |
| $TMOUT | The number of seconds of idle time before logout |
| $OPTIND | The index of the next argument to be processed by getopts |
| $OPTARG | The last option argument processed by getopts |
| $REPLY | The last line read by the read builtin command |
| $FUNCNAME | The name of the current function |

### Special Variables

| Variable | Description |
| --- | --- |
| $0 | The name of the Bash script |
| $n | These variables correspond to the arguments with which a script was invoked. For example, $1 is the first argument and $2 is the second argument. |
| $# | The number of arguments supplied to a script |
| $* | All the arguments are double quoted. If a script receives two arguments, $* is equivalent to $1 $2. |
| $@ | All the arguments are individually double quoted. If a script receives two arguments, $@ is equivalent to $1 $2. |
| $? | The exit status of the last command executed |
| $$ | The process number of the current script |
| $! | The process number of the last background command |
| $- | The current options set for the shell |
| $_ | The last argument of the previous command |


## Command Line Arguments

The arguments are stored in special variables. The first argument is stored in $1, the second in $2, and so on.

```bash
#!/bin/bash
echo $1 $2 $3 ' -> echo $1 $2 $3'
args=("$@")
echo ${args[0]} ${args[1]} ${args[2]} ' -> args=("$@"); echo ${args[0]} ${args[1]} ${args[2]}'

# ---------------

echo "File Name: $0"
echo "First Parameter : $1"
echo "Second Parameter : $2"
echo "Quoted Values: $@"
echo "Quoted Values: $*"
echo "Total Number of Parameters 
```

## Operators

### Arithmetic Operators

| Operator | Description |
| --- | --- |
| + | Addition |
| - | Subtraction |
| * | Multiplication |
| / | Division |
| % | Modulus |
| ** | Exponentiation |
| ++ | Increment |
| -- | Decrement |
| = | Assignment |

### Relational Operators

| Operator | Description |
| --- | --- |
| -eq | Returns true if the values are equal |
| -ne | Returns true if the values are not equal |
| -gt | Returns true if the left operand is greater than the right operand |
| -ge | Returns true if the left operand is greater than or equal to the right operand |
| -lt | Returns true if the left operand is less than the right operand |
| -le | Returns true if the left operand is less than or equal to the right operand |


### Logical Operators

| Operator | Description |
| --- | --- |
| ! | Returns true if the statement is false |
| -o | Returns true if either statement is true |
| -a | Returns true if both statements are true |
| && | Returns true if both statements are true |
| \|\| | Returns true if either statement is true |
| & | Returns true if both statements are true |
| \| | Returns true if either statement is true |
| ^ | Returns true if either statement is true, but not both |
| ~ | Returns true if the pattern matches |
| =~ | Returns true if the pattern matches |

### String Operators

| Operator | Description |
| --- | --- |
| = | Returns true if the strings are equal |
| != | Returns true if the strings are not equal |
| -z | Returns true if the string is empty |
| -n | Returns true if the string is not empty |
| str | Returns true if the string is not empty |

### File Operators

| Operator | Description |
| --- | --- |
| -b | Returns true if the file is a block special file |
| -c | Returns true if the file is a character special file |
| -d | Returns true if the file is a directory |
| -e | Returns true if the file exists (note that this is not particularly portable, thus -f is generally used) |
| -f | Returns true if the provided string is a file |
| -g | Returns true if the group id is set on a file |
| -k | Returns true if the sticky bit is set |
| -p | Returns true if the file is a named pipe |
| -r | Returns true if the file is readable |
| -s | Returns true if the file has a non-zero size |
| -t | Returns true if the file descriptor is open and associated with a terminal |
| -u | Returns true if the user id is set on a file |
| -w | Returns true if the file is writable |
| -x | Returns true if the file is an executable |

## Arrays Variables

```bash
#!/bin/bash
my_array=("A" "B" "C" "D" "E")
```

### Accessing Array Elements

```bash
#!/bin/bash
my_array=("A" "B" "C" "D" "E")
echo ${my_array[0]}
echo ${my_array[1]}
echo ${my_array[2]}
echo ${my_array[3]}
```

### Append Elements to an Array

```bash
#!/bin/bash
my_array=("A" "B" "C" "D" "E")
my_array+=("F")
echo ${my_array[@]}
```

### Get the Length of an Array

```bash
#!/bin/bash
my_array=("A" "B" "C" "D" "E")
echo ${#my_array[@]}
```

### Get the Length of an Array Element

```bash
#!/bin/bash
my_array=("A" "B" "C" "D" "E")
echo ${#my_array[0]}
```

## Conditional Statements

### if Statement

```bash
#!/bin/bash
if [ 1 -eq 1 ]
then
    echo "1 -eq 1 : true"
fi
```

### if-else Statement

```bash
#!/bin/bash
if [ 1 -eq 1 ]
then
    echo "1 -eq 1 : true"
else
    echo "1 -eq 1 : false"
fi
```

### if-elif-else Statement

```bash
#!/bin/bash
if [ 1 -eq 1 ]
then
    echo "1 -eq 1 : true"
elif [ 1 -eq 2 ]
then
    echo "1 -eq 2 : true"
else
    echo "1 -eq 1 : false"
fi
```

### Nested if Statement

```bash
#!/bin/bash
if [ 1 -eq 1 ]
then
    echo "1 -eq 1 : true"
    if [ 1 -eq 2 ]
    then
        echo "1 -eq 2 : true"
    else
        echo "1 -eq 2 : false"
    fi
else
    echo "1 -eq 1 : false"
fi
```

### Case Statement

```bash
#!/bin/bash
echo "Enter a number between 1 and 3:"
read aNumber
case $aNumber in
    1) echo "You entered #1";;
    2) echo "You entered #2";;
    3) echo "You entered #3";;
    *) echo "You did not follow directions!";;
esac
```
### For Loop

```bash
#!/bin/bash
for i in 1 2 3 4 5
do
    echo "Welcome $i times"
done
```

### While Loop

```bash
#!/bin/bash
i=1
while [ $i -le 5 ]
do
    echo "Welcome $i times"
    i=$((i+1))
done
```

### Until Loop

```bash
#!/bin/bash
i=1
until [ $i -gt 5 ]
do
    echo "Welcome $i times"
    i=$((i+1))
done
```

### Break Statement

```bash
#!/bin/bash
for i in 1 2 3 4 5
do
    echo "Welcome $i times"
    if [ $i -eq 3 ]
    then
        break
    fi
done
```

### Continue Statement

```bash
#!/bin/bash
for i in 1 2 3 4 5
do
    if [ $i -eq 3 ]
    then
        continue
    fi
    echo "Welcome $i times"
done
```

### Select Statement

```bash
#!/bin/bash
select name in "Mark" "John" "Tom"
do
    echo "Hello $name"
done
```

## Shell Substitutions

The substitution is the process of replacing a portion of a string with another string. The shell performs substitution on a string when it is assigned to a variable or when it is used as an argument to a command.

### Command Substitution

```bash
#!/bin/bash
today=$(date)
echo "Today is $today"
```

### Arithmetic Substitution

```bash
#!/bin/bash
a=10
b=20
c=$((a+b))
echo "c = $c"
```

### Brace Expansion

```bash
#!/bin/bash
echo {A..Z}
echo {a..z}
echo {0..9}
```

|Escape Sequence|Description|
|---|---|
|\\|Backslash|
|\a|Alert (Beep, Bell)|
|\b|Backspace|
|\c|Produce no further output|
|\f|Formfeed|
|\n|Newline|
|\r|Carriage Return|
|\t|Horizontal Tab|
|\v|Vertical Tab|

### Variable Substitution

Enables you to substitute the value of a variable or the output of a command into a string.

|Escape Sequence|Description|
|---|---|
|${var}|Substitute the value of var|
|${var:-word}|If var is unset or null, the expansion of word is substituted. Otherwise, the value of var is substituted.|
|${var:=word}|If var is unset or null, the expansion of word is assigned to var. The value of var is then substituted.|
|${var:?word}|If var is unset or null, the expansion of word (or a message to that effect if word is not present) is written to the standard error and the shell, if it is not interactive, exits. Otherwise, the value of var is substituted.|
|${var:+word}|If var is null or unset, nothing is substituted, otherwise the expansion of word is substituted.|
|${#var}|The length of the value of var is substituted.|
|${var:offset}|The substring of var starting at offset is substituted. An offset of 0 is the first character of the string.|
|${var:offset:length}|The substring of var starting at offset and extending for length characters is substituted.|
|${var#word}|The shortest match of the front of var against the regular expression pattern formed from word is deleted.|
|${var##word}|The longest match of the front of var against the regular expression pattern formed from word is deleted.|
|${var%word}|The shortest match of the back of var against the regular expression pattern formed from word is deleted.|
|${var%%word}|The longest match of the back of var against the regular expression pattern formed from word is deleted.|
|${var/word/replacement}|The first match of the regular expression pattern formed from word is replaced with replacement.|
|${var//word/replacement}|All matches of the regular expression pattern formed from word are replaced with replacement.|
|${var/#word/replacement}|If the front of var matches the regular expression pattern formed from word, then the match is replaced with replacement.|
|${var/%word/replacement}|If the back of var matches the regular expression pattern formed from word, then the match is replaced with replacement.|

## Functions

```bash
#!/bin/bash
function hello {
    echo "Hello World"
}

hello
```


